package org.nebulostore.dht.core;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import net.tomp2p.peers.Number160;

import org.apache.log4j.Logger;

/**
 * Key for objects in DHTs present in nebulostore.
 *
 * It is used both by internal communication module and by higher-level modules.
 * To differentiate between them when using Kademlia for both purposes use
 * combine function.
 *
 * @author marcin
 * @author Grzegorz Milka
 */
public class KeyDHT implements Serializable {
  private static Logger logger_ = Logger.getLogger(KeyDHT.class);
  private static final long serialVersionUID = 3261126809266422452L;
  /* Key prefixes to avoid collision with naming rows.
   *
   * Module Key used for multiplexing records inside tp2pDHT TP2P is used by
   * both higher modules and communication addressing. To separate records of
   * both layers the Number160 generated by KeyDHT is combination of the layer
   * key (higher module or adressing) and actual key of an object.*/
  public static final Number160 COMMUNICATION_KEY = new Number160(0);
  public static final Number160 NONADDRESSING_KEY = new Number160(1);

  private static final int FIRST_KEY_LEN = 32;
  private static final int SECOND_KEY_LEN = 128;
  private static final int HASH_MULTIPLICATOR = 37;
  private final BigInteger key_;

  public KeyDHT(BigInteger key) {
    key_ = key;
  }

  public KeyDHT(String key) {
    key_ = new BigInteger(key);
  }

  /**
   * To differentiate between objects in communication layer and higher module
   * objects this function combines firstKey identifying layer and secondKey
   * identifying the object itself.
   */
  public static Number160 combine(Number160 firstKey, Number160 secondKey) {
    int firstKeyMaxLength = FIRST_KEY_LEN;
    int secondKeyMaxLength = SECOND_KEY_LEN;

    if (firstKey.bitLength() > firstKeyMaxLength ||
        secondKey.bitLength() > secondKeyMaxLength) {
      throw new IllegalArgumentException("Keys have to adhere to length constraints.");
    }

    int[] val1 = firstKey.toIntArray();
    int[] val2 = secondKey.toIntArray();

    val2[0] = val1[4];
    val2[1] = val2[1];
    val2[2] = val2[2];
    val2[3] = val2[3];
    val2[4] = val2[4];
    return new Number160(val2);
  }

  @Override
  public String toString() {
    return key_.toString();
  }

  public BigInteger getBigInt() {
    return key_;
  }

  public byte[] getBytes() {
    return key_.toByteArray();
  }

  public Number160 getNumber160() {
    return new Number160(getBytes());
  }

  @Override
  public int hashCode() {
    int result = 1;
    result = HASH_MULTIPLICATOR * result + ((key_ == null) ? 0 : key_.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    } else if (obj == null) {
      return false;
    } else if (getClass() != obj.getClass()) {
      return false;
    }
    KeyDHT other = (KeyDHT) obj;
    if (key_ == null) {
      if (other.key_ != null) {
        return false;
      }
    } else if (!key_.equals(other.key_)) {
      return false;
    }
    return true;
  }

  public static KeyDHT fromSerializableObject(Serializable object) {
    // TODO: This - getBytes() is platform dependent, change this

    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = null;
    try {
      oos = new ObjectOutputStream(baos);
      oos.writeObject(object);
    } catch (IOException e1) {
      logger_.warn("IOException when deserializing object: " + e1);
    }

    byte[] val = baos.toByteArray();

    MessageDigest md;
    try {
      md = MessageDigest.getInstance("SHA-1");
      return new KeyDHT(new BigInteger(1, md.digest(val)));
    } catch (NoSuchAlgorithmException e) {
      logger_.fatal(e);
      return null;
    }
  }
}
